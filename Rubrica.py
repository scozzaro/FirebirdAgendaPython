# =============================================================================
# Nome file: Rubrica.py
# Autore: Vincenzo Scozzaro
# Repository: https://github.com/scozzaro/
#
# Copyright (c) 2025 Vincenzo Scozzaro
#
# Questo file è distribuito secondo i termini della Mozilla Public License, v. 2.0.
# Puoi ottenere una copia della licenza all'indirizzo: https://mozilla.org/MPL/2.0/
#
# In base a questa licenza:
# - Sei libero di usare, modificare e distribuire questo file, anche in progetti commerciali.
# - Le modifiche a questo file devono essere rilasciate sotto MPL 2.0.
# - Devono essere mantenuti i riferimenti all’autore e alla licenza.
#
# Il codice è fornito "così com'è", senza garanzie di alcun tipo.
# =============================================================================

from firebird.driver import connect
import tkinter as tk
from tkinter import messagebox, ttk
from collections import namedtuple

# ===== Base Manager =====
class FirebirdManagerBase:
    def __init__(self, host, remote_path, user='SYSDBA', password='masterkey'):
        self.db_path = f'{host}:{remote_path}'
        self.user = user
        self.password = password
        self.conn = None
        self.cursor = None

    def connetti(self):
        self.conn = connect(database=self.db_path, user=self.user, password=self.password)
        self.cursor = self.conn.cursor()

    def chiudi(self):
        if self.cursor:
            self.cursor.close()
        if self.conn:
            self.conn.close()

class FirebirdClientiManager(FirebirdManagerBase):
    def __init__(self, host, remote_path, user='SYSDBA', password='masterkey'):
        super().__init__(host, remote_path, user, password)
        self.clienti = []
        self.posizione_corrente = 0

    def connetti(self):
        self.conn = connect(database=self.db_path, user=self.user, password=self.password)
        self.cursor = self.conn.cursor()

    def crea_tabella_se_necessario(self):
        self.cursor.execute("SELECT 1 FROM RDB$RELATIONS WHERE RDB$RELATION_NAME = 'CLIENTI'")
        if not self.cursor.fetchone():
            self.cursor.execute('''
                CREATE TABLE clienti (
                    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    nome VARCHAR(100),
                    indirizzo VARCHAR(255)
                )
            ''')
            self.conn.commit()

    def inserisci_cliente(self, nome, indirizzo):
        self.cursor.execute('INSERT INTO clienti (nome, indirizzo) VALUES (?, ?)', (nome, indirizzo))
        self.conn.commit()

    def aggiorna_cliente(self, id_cliente, nome, indirizzo):
        self.cursor.execute('UPDATE clienti SET nome = ?, indirizzo = ? WHERE id = ?', (nome, indirizzo, id_cliente))
        self.conn.commit()

    def leggi_clienti(self):
        self.cursor.execute('SELECT id, nome, indirizzo FROM clienti ORDER BY id')
        descrizione = [d[0].lower() for d in self.cursor.description]
        Cliente = namedtuple("Cliente", descrizione)
        self.clienti = [Cliente(*row) for row in self.cursor.fetchall()]
        self.posizione_corrente = 0
        return self.clienti

    def cliente_corrente(self):
        if self.clienti:
            return self.clienti[self.posizione_corrente]
        return None

    def primo(self):
        if self.clienti:
            self.posizione_corrente = 0

    def ultimo(self):
        if self.clienti:
            self.posizione_corrente = len(self.clienti) - 1

    def precedente(self):
        if self.clienti and self.posizione_corrente > 0:
            self.posizione_corrente -= 1

    def successivo(self):
        if self.clienti and self.posizione_corrente < len(self.clienti) - 1:
            self.posizione_corrente += 1

    def chiudi(self):
        if self.cursor:
            self.cursor.close()
        if self.conn:
            self.conn.close()


class AppClienti(tk.Tk):
    def __init__(self, db_manager):
        super().__init__()
        self.db = db_manager
        self.title("Gestione Clienti Firebird")
        self.geometry("600x500")

        self.crea_widgets()
        self.aggiorna_lista_clienti()
        self.mostra_cliente_corrente()

    def seleziona_record(self, event):
        selected = self.tree.focus()
        if not selected:
            return

        values = self.tree.item(selected, 'values')
        if values:
            try:
                id_selezionato = int(values[0])
                for i, cliente in enumerate(self.db.clienti):
                    if cliente.id == id_selezionato:
                        self.db.posizione_corrente = i
                        break
            except:
                pass
            self.mostra_cliente_corrente()

    def seleziona_nella_treeview(self):
        if 0 <= self.db.posizione_corrente < len(self.db.clienti):
            id_corrente = self.db.cliente_corrente().id
            for item in self.tree.get_children():
                if str(self.tree.item(item, 'values')[0]) == str(id_corrente):
                    self.tree.selection_set(item)
                    self.tree.focus(item)
                    self.tree.see(item)
                    break

    def crea_widgets(self):
 
        self.tree = ttk.Treeview(self, columns=("ID", "Nome", "Indirizzo"), show="headings", height=8)
        self.tree.heading("ID", text="ID")
        self.tree.heading("Nome", text="Nome")
        self.tree.heading("Indirizzo", text="Indirizzo")

        # Imposta larghezza delle colonne
        self.tree.column("ID", width=15, anchor='center')         # ID: 15 pixel
        self.tree.column("Nome", width=100, anchor='w')            # Nome: 100 pixel
        self.tree.column("Indirizzo", width=200, anchor='w')       # Indirizzo: 200 pixel

        self.tree.grid(row=3, column=0, columnspan=2, padx=10, pady=10, sticky="nsew")
        self.tree.bind("<<TreeviewSelect>>", self.seleziona_record)
        
        
        nav_frame = tk.Frame(self)
        nav_frame.grid(row=4, column=0, columnspan=2, pady=5)
        tk.Button(nav_frame, text="⏮ Primo", command=self.primo).pack(side=tk.LEFT, padx=5)
        tk.Button(nav_frame, text="◀ Precedente", command=self.precedente).pack(side=tk.LEFT, padx=5)
        tk.Button(nav_frame, text="Successivo ▶", command=self.successivo).pack(side=tk.LEFT, padx=5)
        tk.Button(nav_frame, text="Ultimo ⏭", command=self.ultimo).pack(side=tk.LEFT, padx=5)

        info_frame = tk.Frame(self)
        info_frame.grid(row=5, column=0, columnspan=2, pady=10)

        tk.Label(info_frame, text="ID:").grid(row=0, column=0, padx=5, sticky="e")
        self.lbl_id = tk.Label(info_frame, text="", width=10)
        self.lbl_id.grid(row=0, column=1, padx=5, sticky="w")

        tk.Label(info_frame, text="Nome:").grid(row=1, column=0, padx=5, sticky="e")
        self.entry_nome_modifica = tk.Entry(info_frame, width=30)
        self.entry_nome_modifica.grid(row=1, column=1, padx=5, sticky="w")

        tk.Label(info_frame, text="Indirizzo:").grid(row=2, column=0, padx=5, sticky="e")
        self.entry_indirizzo_modifica = tk.Entry(info_frame, width=40)
        self.entry_indirizzo_modifica.grid(row=2, column=1, padx=5, sticky="w")

        # Nuovo, Salva, Modifica, Elimina
        self.btn_nuovo = tk.Button(info_frame, text="Nuovo", command=self.nuovo_cliente)
        self.btn_nuovo.grid(row=3, column=0, pady=5)

        self.btn_salva = tk.Button(info_frame, text="Salva", command=self.salva_cliente, state="disabled")
        self.btn_salva.grid(row=3, column=1, pady=5)

        self.btn_modifica = tk.Button(info_frame, text="Modifica", command=self.modifica_cliente)
        self.btn_modifica.grid(row=4, column=0, pady=5)

        self.btn_elimina = tk.Button(info_frame, text="Elimina", command=self.elimina_cliente)
        self.btn_elimina.grid(row=4, column=1, pady=5)


    def nuovo_cliente(self):
        self.entry_nome_modifica.delete(0, tk.END)
        self.entry_indirizzo_modifica.delete(0, tk.END)
        self.lbl_id.config(text="")
        self.btn_salva.config(state="normal")
        self.modalita = "nuovo"
        self.btn_nuovo.config(state="disabled")
        self.btn_modifica.config(state="disabled")
        self.btn_elimina.config(state="disabled")

    def modifica_cliente(self):
        cliente = self.db.cliente_corrente()
        if not cliente:
            messagebox.showwarning("Attenzione", "Nessun cliente selezionato.")
            return
        self.modalita = "modifica"
        self.id_cliente_in_modifica = cliente.id  # <-- memorizzo l'ID
        self.btn_salva.config(state="normal")
        self.btn_nuovo.config(state="disabled")
        self.btn_modifica.config(state="disabled")
        self.btn_elimina.config(state="disabled")


    def salva_cliente(self):
        nome = self.entry_nome_modifica.get().strip()
        indirizzo = self.entry_indirizzo_modifica.get().strip()

        if not nome or not indirizzo:
            messagebox.showwarning("Campi mancanti", "Inserisci sia nome che indirizzo.")
            return

        if self.modalita == "nuovo":
            self.db.inserisci_cliente(nome, indirizzo)
            messagebox.showinfo("Successo", "Cliente inserito.")
        elif self.modalita == "modifica":
            if self.id_cliente_in_modifica is not None:
                self.db.aggiorna_cliente(self.id_cliente_in_modifica, nome, indirizzo)
                messagebox.showinfo("Successo", "Cliente aggiornato.")
            else:
                messagebox.showwarning("Errore", "ID cliente non disponibile per la modifica.")
                return
        else:
            return

        self.aggiorna_lista_clienti()

        # --- Dopo aver aggiornato ricerchiamo il record modificato
        if self.modalita == "modifica" and self.id_cliente_in_modifica is not None:
            for i, cliente in enumerate(self.db.clienti):
                if cliente.id == self.id_cliente_in_modifica:
                    self.db.posizione_corrente = i
                    break

        self.mostra_cliente_corrente()
        self.btn_salva.config(state="disabled")
        self.btn_nuovo.config(state="normal")
        self.btn_modifica.config(state="normal")
        self.btn_elimina.config(state="normal")
        self.modalita = None
        self.id_cliente_in_modifica = None  # <-- Resetto l'ID

    def elimina_cliente(self):
        cliente = self.db.cliente_corrente()
        if not cliente:
            messagebox.showwarning("Attenzione", "Nessun cliente selezionato.")
            return
        conferma = messagebox.askyesno("Conferma", "Eliminare questo cliente?")
        if conferma:
            try:
                self.db.cursor.execute("DELETE FROM clienti WHERE id = ?", (cliente.id,))
                self.db.conn.commit()
                messagebox.showinfo("Successo", "Cliente eliminato.")
                self.aggiorna_lista_clienti()
                self.mostra_cliente_corrente()
            except Exception as e:
                messagebox.showerror("Errore", f"Errore durante l'eliminazione: {e}")

    def carica_cliente(self):
        nome = self.entry_nome_modifica.get().strip()
        indirizzo = self.entry_indirizzo_modifica.get().strip()

        if not nome or not indirizzo:
            messagebox.showwarning("Campi mancanti", "Inserisci sia il nome che l'indirizzo.")
            return

        try:
            self.db.inserisci_cliente(nome, indirizzo)
            messagebox.showinfo("Successo", "Cliente salvato con successo.")
            self.entry_nome_modifica.delete(0, tk.END)
            self.entry_indirizzo_modifica.delete(0, tk.END)
            self.aggiorna_lista_clienti()
        except Exception as e:
            messagebox.showerror("Errore", f"Errore durante il salvataggio: {e}")

    def aggiorna_cliente(self):
        nome = self.entry_nome_modifica.get().strip()
        indirizzo = self.entry_indirizzo_modifica.get().strip()

        if not nome or not indirizzo:
            messagebox.showwarning("Campi mancanti", "Inserisci sia il nome che l'indirizzo.")
            return

        cliente = self.db.cliente_corrente()
        if cliente:
            try:
                id_corrente = cliente.id  # <-- Salva l'ID del cliente corrente

                self.db.aggiorna_cliente(id_corrente, nome, indirizzo)
                messagebox.showinfo("Successo", "Cliente aggiornato con successo.")

                self.aggiorna_lista_clienti()

                # Trova la nuova posizione del cliente aggiornato
                for i, c in enumerate(self.db.clienti):
                    if c.id == id_corrente:
                        self.db.posizione_corrente = i
                        break

                self.mostra_cliente_corrente()
                self.seleziona_nella_treeview()

            except Exception as e:
                messagebox.showerror("Errore", f"Errore durante l'aggiornamento: {e}")



    def aggiorna_lista_clienti(self):
        for row in self.tree.get_children():
            self.tree.delete(row)

        clienti = self.db.leggi_clienti()
        for cliente in clienti:
            self.tree.insert("", "end", values=(cliente.id, cliente.nome, cliente.indirizzo))

    def mostra_cliente_corrente(self):
        cliente = self.db.cliente_corrente()
        if cliente:
            self.lbl_id.config(text=str(cliente.id))
            self.entry_nome_modifica.delete(0, tk.END)
            self.entry_nome_modifica.insert(0, cliente.nome)
            self.entry_indirizzo_modifica.delete(0, tk.END)
            self.entry_indirizzo_modifica.insert(0, cliente.indirizzo)
            self.btn_nuovo.config(state="normal")
            self.btn_modifica.config(state="normal")
            self.btn_elimina.config(state="normal")
        else:
            self.lbl_id.config(text="")
            self.entry_nome_modifica.delete(0, tk.END)
            self.entry_indirizzo_modifica.delete(0, tk.END)
            self.btn_nuovo.config(state="normal")
            self.btn_modifica.config(state="disabled")
            self.btn_elimina.config(state="disabled")
            self.btn_salva.config(state="disabled")


    def primo(self):
        self.db.primo()
        self.mostra_cliente_corrente()
        self.seleziona_nella_treeview()

    def ultimo(self):
        self.db.ultimo()
        self.mostra_cliente_corrente()
        self.seleziona_nella_treeview()

    def precedente(self):
        self.db.precedente()
        self.mostra_cliente_corrente()
        self.seleziona_nella_treeview()

    def successivo(self):
        self.db.successivo()
        self.mostra_cliente_corrente()
        self.seleziona_nella_treeview()

# ===== Main Window =====
class MainWindow(tk.Tk):
    def __init__(self, db_clienti, db_fornitori):
        super().__init__()
        self.title("Gestione Firebird")
        self.geometry("300x200")
        self.db_clienti = db_clienti
        self.db_fornitori = db_fornitori
        self.clienti_win = None
        self.fornitori_win = None
        self.crea_menu()

    def crea_menu(self):
        menubar = tk.Menu(self)
        clienti_menu = tk.Menu(menubar, tearoff=0)
        clienti_menu.add_command(label="Gestione Clienti", command=self.open_clienti)
        menubar.add_cascade(label="Clienti", menu=clienti_menu)
        #fornitori_menu = tk.Menu(menubar, tearoff=0)
        #fornitori_menu.add_command(label="Gestione Fornitori", command=self.open_fornitori)
        #menubar.add_cascade(label="Fornitori", menu=fornitori_menu)
        self.config(menu=menubar)

    def open_clienti(self):
        if not self.clienti_win or not self.clienti_win.winfo_exists():
            self.withdraw()
            self.clienti_win = AppClienti(self, self.db_clienti)
        else:
            self.clienti_win.lift()

   


if __name__ == '__main__':
    host = '192.168.1.202'
    path = '/Users/scozzaro/Downloads/test/database.fdb'

    db = FirebirdClientiManager(host, path)
    try:
        db.connetti()
        db.crea_tabella_se_necessario()

        
        app = AppClienti(db)
        app.mainloop()
    finally:
        db.chiudi()
